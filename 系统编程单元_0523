进程概念->进程控制->基础IO->进程间通信->进程信号->多线程

一、进程概念
	冯诺依曼体系结构---现代计算机硬件体系结构 5大单元
		输入设备:键盘
		输出设备:显示器
		存储器:内存
		运算器:CPU中央处理器
		控制器:
		
	操作系统的---如何管理
		目的:让计算机更好用.
		定位:一款搞管理的软件-管理软硬件资源,提供良好的执行环境
		如何管理:先描述,再组织
			管理者并不需要与被管理者交互管理,而是通过被管理者的描述管理,并且将描述信息得当的组织起来进行管理
			操作系统通过驱动程序对设备进行管理(驱动程序传递设备的描述信息)
			应用程序->shell命令->系统调用接口->操作系统->驱动程序->键盘、显示器、鼠标
			
			库函数与系统调用接口的关系:
				库函数是对系统调用接口的一层封装,是上下级的调用关系
	
	进程概念:
		进程是什么:
			用户层面:		进程就是运行起来的程序
			操作系统层面:	程序运行需要将代码数据加载到内存中,操作系统上运行了很多程序,操作系统就必须去管理这些程序的运行,先描述再组织进行管理,
							在操作系统的层面进程就是操作系统对一个运行的程序的描述,
							操作系统眼中看到了对运行程序的描述就是=等于看到了进程,   这个描述叫做PCB--进程控制块---Linux下就是struct task_struct结构体
					PCB就是进程
					PCB中的描述信息:
						内存指针,程序计数器(下一步执行的指令位置),上下文数据,标识符PID,进程状态,进程优先级(CPU资源的优先使用权,为了让操作系统运行得更合理),记账信息,IO信息(打开的文件处于什么状态)
				
			CPU分时机制:对程序运行处理进行切换调度处理,
			时间片:		cpu在每个程序上所运行的这段时间
	
	如何查看进程:
		ps -ef -aux	       /proc/ 保存运行信息
		pid_t getpid(void) 获取调用进程id	
		
	如何创建进程:
		fork()
		创建子进程的意义:分担任务处理任务;让子进程完成其他任务--背锅
		如何让子进程完成其他任务:分辨父子进程
			返回值:
				对于父进程,fork返回值是子进程的pid>0:创建子进程失败返回1
				对于子进程,fork返回值是0
			用户通过fork返回值不同对父子进程运行流程进行分流
			复制:操作系统通过复制父进程的PCB创建子进程,因此父子进程数据独有,代码共享
			
	进程的状态:(总的:运行,就绪,阻塞)
		Linux下的状态:
			运行R:要么在运行,要么在运行队列里
			可中断休眠S:
			不可中断休眠D:
			停止T:
			僵死Z:僵尸进程--处于僵死状态的进程
				产生原因:子进程先于父进程退出,系统要通知父进程获取返回值并且允许系统释放这个子进程资源,父进程没有关注这个通知导致子进程退出后无法释放所有资源,处于僵死状态,成为僵尸进程
				危害:资源泄露
				如何避免:进程等待
				处理方式:退出父进程
				避免僵尸进程:进程等待
			孤儿进程:父进程先于子进程退出,运行在后台,父进程成为1号进程(使其不成为僵死进程)
			守护进程/精灵进程:特殊的孤儿进程,文件中以d为结尾
	
	环境变量:存储系统运行环境参数的变量----让系统的参数设置更加简单
		查看环境变量:env
					 set
					 echo
		添加环境变量:export关键字
		删除环境变量:unset
		常见的环境变量:HOME USER PWD SHELL PATH(path是程序运行的默认查找路径)
		特性:全局特性(父子进程间的继承关系)
			shell终端下运行的所有程序能获取到所有环境变量,但获取不到普通变量
		环境变量在代码中的获取:
			char* getenv(char* name)
			main函数的第三个参数 int main(int argc, char ^argc[], char* env[]) putenv setenv
			extern char **environ	声明全局变量
		删除环境变量: unset
		使用场景:父进程给子进程传递数据
	
	程序地址空间:32位操作系统中,内存寻址范围2-2的32次方,四个字节 只有4G内存
		内核空间是3G,用户空间1G
		0x 00 00 00 00 - 0x c0 00 00 00 是用户空间为 代码段->初始化全局数据段->未初始化全局数据段->堆->共享区->栈->环境变量运行参数->内核空间
		0x c0 00 00 00 - 0x ff ff ff ff 是内核空间
		
		百度网盘的例子
		进程之间数据独有
		内存地址:就是内存区域的编号
		虚拟地址:虚拟地址空间:
			是一个结构体 struct mm_struct
						{
							ulong mem_size;//内存空间大小
							ulong code_start;//内存开始位置
							ulong code_end;//内存结束位置
							
						}
			每个程序都需要连续的内存空间
			
		我们所看到的程序地址空间实际上是一个虚拟地址空间,实际上是操作系统通过mm_struct这个结构体为进程描述的一个空间,因此有时候也称作内存描述符
		
		为什么要使用虚拟地址空间: 进程在通过访问虚拟地址进而获取变量数据,最终还是要去访问物理内存,因为数据是存储在物理内存中的,在虚拟地址和物理地址之间通过页表进行地址映射,转换得到物理地址
									进而访问物理内存,映射之后,物理地址不一定连续,通过这种映射转换的方式实现数据的离散存储提高内存的利用率
									
				页表中不但记录了虚拟地址和物理地址的映射关系,并且还记录了这块地址的属性实现内存访问控制
		
		创建子进程时发生了什么?
			写时拷贝技术:操作系统通过复制父进程时创建子进程,子进程初始时与父进程指向同一块物理内存区域,当内存数据发生变化时,会为子进程重新开辟内存更新页表
			
		进程的独立性:进程应该有独立性,独立才能稳定
		
		虚拟地址空间和页表有什么用:提高内存利用率,增加内存访问控制,保持进程独立性
		
		页表是如何将虚拟地址转化为物理地址的:
			分段式内存管理:
				内存地址的构成:段起始地址+段内偏移  段号+ 段内偏移				分页式内存管理:
				段表--有很多的段表项												内存地址的构成:页号+页内偏移
																					页表---很多页表项:
																					
			段页式内存管理:
				内存地址:段号+段内页号+页内偏移
		
		虚拟地址如何存储数据:
	
	进程调度算法和优先级(选学):
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	